from __future__ import annotations

from typing import Dict, List, Optional

class ExtractorType:
    """Extractor type metadata."""
    @property
    def kind(self) -> str: ...
    @property
    def value(self) -> Optional[str]: ...

class Extractor:
    """Extractor metadata for a signature."""
    @property
    def utility(self) -> ExtractorType: ...
    @property
    def extension(self) -> str: ...
    @property
    def arguments(self) -> List[str]: ...
    @property
    def exit_codes(self) -> List[int]: ...
    @property
    def do_not_recurse(self) -> bool: ...

class SignatureResult:
    """Signature match result returned by scan_bytes/scan_path."""
    @property
    def offset(self) -> int: ...
    @property
    def id(self) -> str: ...
    @property
    def size(self) -> int: ...
    @property
    def name(self) -> str: ...
    @property
    def confidence(self) -> int: ...
    @property
    def description(self) -> str: ...
    @property
    def always_display(self) -> bool: ...
    @property
    def extraction_declined(self) -> bool: ...
    @property
    def preferred_extractor(self) -> Optional[Extractor]: ...

class ExtractionResult:
    """Extraction result for a signature id."""
    @property
    def size(self) -> Optional[int]: ...
    @property
    def success(self) -> bool: ...
    @property
    def extractor(self) -> str: ...
    @property
    def do_not_recurse(self) -> bool: ...
    @property
    def output_directory(self) -> str: ...

class AnalysisResults:
    """Analysis results returned by analyze_path."""
    @property
    def file_path(self) -> str: ...
    @property
    def file_map(self) -> List[SignatureResult]: ...
    @property
    def extractions(self) -> Dict[str, ExtractionResult]: ...

class Binwalk:
    """Binwalk engine bindings.

    scan_path(): reads from disk (avoid huge Python memory copies).
    scan_bytes(): use when you already have data in memory.
    """

    def __init__(self) -> None: ...

    @staticmethod
    def configure(
        target_file_name: Optional[str] = None,
        output_directory: Optional[str] = None,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        full_search: bool = False,
    ) -> Binwalk: ...

    def scan_bytes(self, data: bytes) -> List[SignatureResult]: ...
    def scan_path(self, file_path: str) -> List[SignatureResult]: ...
    def extract_bytes(
        self,
        data: bytes,
        file_path: str,
        file_map: List[SignatureResult],
    ) -> Dict[str, ExtractionResult]: ...
    def analyze_path(self, target_file: str, do_extraction: bool) -> AnalysisResults: ...

    @property
    def signature_count(self) -> int: ...
    @property
    def base_target_file(self) -> str: ...
    @property
    def base_output_directory(self) -> str: ...

def version() -> str: ...
